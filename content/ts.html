<section id="ts-intro" class="topic active">
  <h2>üìò TypeScript ‚Äî Sistema de Tipos</h2>

  <div class="mini-index">
    <strong>Nesta se√ß√£o voc√™ encontra:</strong>
    Introdu√ß√£o ¬∑ Tipos b√°sicos ¬∑ Objetos e interfaces ¬∑ Generics ¬∑ Type Guards ¬∑ Utility types ¬∑ Decorators ¬∑ tsconfig.json ¬∑ Boas pr√°ticas.
  </div>

  <h3>Introdu√ß√£o</h3>
  <p><strong>O que √©:</strong> TypeScript √© um "superconjunto" do JavaScript, ou seja, tudo que existe em JS existe em TS, com o extra de tipagem est√°tica.</p>
  <p><strong>Por que usar:</strong> encontrar erros mais cedo, deixar o c√≥digo mais previs√≠vel e facilitar manuten√ß√£o em projetos grandes.</p>

  <p><em>üìå Nota: Os fundamentos de programa√ß√£o (vari√°veis, operadores, loops, estruturas de dados, etc.) est√£o na se√ß√£o de JavaScript. Esta se√ß√£o foca exclusivamente no sistema de tipos do TypeScript.</em></p>

  <pre><code>// Instalar TypeScript globalmente (via npm):
// npm install -g typescript

// Compilar arquivo:
// tsc arquivo.ts</code></pre>
</section>

<section id="ts-tipos-basicos" class="topic">
  <h3>Tipos b√°sicos</h3>

  <h4>Primitivos</h4>
  <p><strong>O que √©:</strong> tipos mais simples: <code>string</code>, <code>number</code>, <code>boolean</code> etc.</p>
  <p><strong>Por que usar:</strong> deixam claro que tipo de dado voc√™ espera e evita usar valores errados.</p>

  <pre><code>let nome: string = "Ana";
let idade: number = 25;
let ativo: boolean = true;

let numeros: number[] = [1, 2, 3];
let nomes: string[] = ["Ana", "Jo√£o"];</code></pre>

  <h4>Any, unknown e never</h4>
  <p><strong>O que √©:</strong> tipos especiais para casos espec√≠ficos.</p>
  <ul>
    <li><strong>any</strong> ‚Äì desliga a checagem de tipo (aceita qualquer coisa);</li>
    <li><strong>unknown</strong> ‚Äì parecido com any, mas obriga checar antes de usar;</li>
    <li><strong>never</strong> ‚Äì fun√ß√£o que nunca retorna (erro ou loop infinito).</li>
  </ul>
  <p><strong>Por que usar:</strong> s√≥ quando necess√°rio: <code>unknown</code> para dados externos, <code>never</code> para fun√ß√µes que sempre lan√ßam erro.</p>

  <pre><code>let algo: any = "teste";   // foge da tipagem, use com cuidado
algo = 123;

let seguro: unknown = "oi"; // mais seguro que any
if (typeof seguro === "string") {
  console.log(seguro.toUpperCase());
}

function erro(msg: string): never {
  throw new Error(msg);
}</code></pre>

  <h4>Union types e type alias</h4>
  <p><strong>O que √©:</strong> forma de dizer que algo pode ser de mais de um tipo e dar um nome para esse conjunto.</p>
  <p><strong>Por que usar:</strong> ajuda a modelar casos em que um valor pode ter mais de uma forma (ex.: id num√©rico ou string).</p>

  <pre><code>type ID = string | number;

let idUsuario: ID = 42;
idUsuario = "abc";

// literal types
type Status = "ativo" | "inativo";

let statusUsuario: Status = "ativo";
// statusUsuario = "pendente"; // erro</code></pre>

  <h4>Enum</h4>
  <p><strong>O que √©:</strong> conjunto de valores nomeados.</p>
  <p><strong>Por que usar:</strong> substitui strings soltas e evita erros de digita√ß√£o.</p>

  <pre><code>enum Cor {
  Vermelho = "vermelho",
  Verde = "verde",
  Azul = "azul"
}

let corEscolhida: Cor = Cor.Vermelho;</code></pre>
</section>

<section id="ts-objetos-interfaces" class="topic">
  <h3>Objetos, interfaces e tipos compostos</h3>

  <h4>Objetos tipados</h4>
  <p><strong>O que √©:</strong> declarar a forma de um objeto (quais propriedades ele tem).</p>
  <p><strong>Por que usar:</strong> evita acessar propriedades inexistentes e documenta os dados.</p>

  <pre><code>let usuario: {
  nome: string;
  idade: number;
  email?: string; // opcional
} = {
  nome: "Maria",
  idade: 30
};</code></pre>

  <h4>Interfaces</h4>
  <p><strong>O que √©:</strong> uma forma reutiliz√°vel de descrever objetos.</p>
  <p><strong>Por que usar:</strong> deixa o c√≥digo mais organizado, principalmente ao trabalhar com fun√ß√µes e classes.</p>

  <pre><code>interface Usuario {
  nome: string;
  idade: number;
  email?: string;
}

const u1: Usuario = {
  nome: "Ana",
  idade: 22
};</code></pre>

  <h4>Extens√£o de interfaces</h4>
  <p><strong>O que √©:</strong> uma interface herdando campos de outra.</p>
  <p><strong>Por que usar:</strong> reaproveitar estruturas comuns, evitando repeti√ß√£o.</p>

  <pre><code>interface Pessoa {
  nome: string;
}

interface Funcionario extends Pessoa {
  cargo: string;
}

const f1: Funcionario = {
  nome: "Jo√£o",
  cargo: "Desenvolvedor"
};</code></pre>

  <h4>Intersection types</h4>
  <p><strong>O que √©:</strong> combina√ß√£o de tipos usando <code>&amp;</code>.</p>
  <p><strong>Por que usar:</strong> quando voc√™ precisa de algo que tenha as propriedades de dois tipos ao mesmo tempo.</p>

  <pre><code>type ComID = { id: number };
type Produto = { nome: string; preco: number };

type ProdutoComID = Produto & ComID;

const prod: ProdutoComID = {
  id: 1,
  nome: "Mouse",
  preco: 50
};</code></pre>
</section>

<section id="ts-generics" class="topic">
  <h3>Generics e recursos avan√ßados</h3>

  <h4>Fun√ß√µes gen√©ricas</h4>
  <p><strong>O que √©:</strong> fun√ß√µes que funcionam com v√°rios tipos, mas ainda assim s√£o tipadas.</p>
  <p><strong>Por que usar:</strong> evita duplicar c√≥digo para cada tipo diferente.</p>

  <pre><code>function primeiroElemento&lt;T&gt;(array: T[]): T | undefined {
  return array[0];
}

const n = primeiroElemento&lt;number&gt;([1, 2, 3]);
const s = primeiroElemento&lt;string&gt;(["a", "b"]);
// n √© number | undefined, s √© string | undefined</code></pre>

  <h4>Interfaces gen√©ricas</h4>
  <p><strong>O que √©:</strong> interfaces que recebem tipos como par√¢metro.</p>
  <p><strong>Por que usar:</strong> muito √∫til para respostas de API, cole√ß√µes, etc.</p>

  <pre><code>interface RespostaAPI&lt;T&gt; {
  dados: T;
  status: number;
  mensagem?: string;
}

interface UsuarioAPI {
  nome: string;
  idade: number;
}

const resp: RespostaAPI&lt;UsuarioAPI&gt; = {
  dados: { nome: "Ana", idade: 25 },
  status: 200
};</code></pre>

  <h4>Narrowing e tipos especiais</h4>
  <p><strong>O que √©:</strong> quando o TypeScript "afina" o tipo baseado em checagens que voc√™ faz.</p>
  <p><strong>Por que usar:</strong> te permite trabalhar com tipos union de forma segura.</p>

  <pre><code>function imprimirId(id: string | number) {
  if (typeof id === "string") {
    console.log(id.toUpperCase());
  } else {
    console.log(id.toFixed(2));
  }
}</code></pre>

  <h4>Utility types importantes</h4>
  <p><strong>O que √©:</strong> tipos prontos que transformam outros tipos.</p>
  <p><strong>Por que usar:</strong> evitam criar varia√ß√µes de tipos na m√£o.</p>

  <pre><code>interface Usuario {
  nome: string;
  idade: number;
  email: string;
}

/* Torna todas as propriedades opcionais */
type UsuarioParcial = Partial&lt;Usuario&gt;;

/* Torna todas obrigat√≥rias */
type UsuarioCompleto = Required&lt;Usuario&gt;;

/* Pega s√≥ algumas propriedades */
type UsuarioPublico = Pick&lt;Usuario, "nome" | "email"&gt;;

/* Remove algumas propriedades */
type UsuarioSemEmail = Omit&lt;Usuario, "email"&gt;;

/* Record: mapa de chaves para um tipo */
type MapaUsuarios = Record&lt;string, Usuario&gt;;

/* Readonly: n√£o pode alterar propriedades */
type UsuarioReadonly = Readonly&lt;Usuario&gt;;</code></pre>

  <h4>keyof e indexed access</h4>
  <p><strong>O que √©:</strong> <code>keyof</code> pega as chaves de um tipo como uni√£o de strings.</p>
  <p><strong>Por que usar:</strong> permite criar fun√ß√µes gen√©ricas que acessam propriedades de forma segura.</p>

  <pre><code>type ChavesUsuario = keyof Usuario; // "nome" | "idade" | "email"

function pegarPropriedade(
  usuario: Usuario,
  chave: ChavesUsuario
) {
  return usuario[chave];
}</code></pre>
</section>

<section id="ts-type-guards" class="topic">
  <h3>Type Guards e Narrowing</h3>
  <p><strong>O que √©:</strong> t√©cnicas para refinar tipos em tempo de execu√ß√£o, permitindo TypeScript entender melhor o c√≥digo.</p>
  <p><strong>Por que usar:</strong> torna o c√≥digo mais seguro e elimina a necessidade de type assertions (as).</p>

  <h4>Typeof guard</h4>
  <pre><code>function processar(valor: string | number) {
  if (typeof valor === "string") {
    // TypeScript sabe que aqui √© string
    return valor.toUpperCase();
  } else {
    // TypeScript sabe que aqui √© number
    return valor.toFixed(2);
  }
}</code></pre>

  <h4>Instanceof guard</h4>
  <pre><code>class Cachorro {
  latir() { console.log("Au au!"); }
}

class Gato {
  miar() { console.log("Miau!"); }
}

function fazerBarulho(animal: Cachorro | Gato) {
  if (animal instanceof Cachorro) {
    animal.latir();
  } else {
    animal.miar();
  }
}</code></pre>

  <h4>In operator (checar propriedade)</h4>
  <pre><code>interface Carro {
  dirigir(): void;
}

interface Barco {
  navegar(): void;
}

function mover(veiculo: Carro | Barco) {
  if ("dirigir" in veiculo) {
    veiculo.dirigir();
  } else {
    veiculo.navegar();
  }
}</code></pre>

  <h4>Type predicate (custom guard)</h4>
  <p><strong>O que √©:</strong> fun√ß√£o que retorna <code>valor is Tipo</code> para criar guards customizados.</p>
  <pre><code>interface Peixe {
  nadar(): void;
}

interface Passaro {
  voar(): void;
}

// Type predicate
function isPeixe(animal: Peixe | Passaro): animal is Peixe {
  return (animal as Peixe).nadar !== undefined;
}

function moverAnimal(animal: Peixe | Passaro) {
  if (isPeixe(animal)) {
    animal.nadar();
  } else {
    animal.voar();
  }
}</code></pre>

  <h4>Discriminated unions</h4>
  <p><strong>O que √©:</strong> usar uma propriedade comum para diferenciar tipos.</p>
  <pre><code>interface Circulo {
  tipo: "circulo";
  raio: number;
}

interface Retangulo {
  tipo: "retangulo";
  largura: number;
  altura: number;
}

type Forma = Circulo | Retangulo;

function calcularArea(forma: Forma) {
  switch (forma.tipo) {
    case "circulo":
      return Math.PI * forma.raio ** 2;
    case "retangulo":
      return forma.largura * forma.altura;
  }
}</code></pre>
</section>

<section id="ts-utility-types" class="topic">
  <h3>Utility Types avan√ßados</h3>
  <p><strong>O que √©:</strong> tipos utilit√°rios embutidos no TypeScript para transformar tipos existentes.</p>
  <p><strong>Por que usar:</strong> evita repeti√ß√£o e torna c√≥digo mais flex√≠vel.</p>

  <h4>Partial&lt;T&gt;</h4>
  <p><strong>O que √©:</strong> torna todas as propriedades opcionais.</p>
  <pre><code>interface Usuario {
  nome: string;
  email: string;
  idade: number;
}

// Partial permite passar apenas algumas propriedades
function atualizarUsuario(id: number, dados: Partial&lt;Usuario&gt;) {
  // pode passar s√≥ { nome: "Jo√£o" } sem email e idade
}

atualizarUsuario(1, { nome: "Jo√£o" });</code></pre>

  <h4>Required&lt;T&gt;</h4>
  <p><strong>O que √©:</strong> torna todas as propriedades obrigat√≥rias.</p>
  <pre><code>interface Config {
  host?: string;
  port?: number;
}

const configCompleta: Required&lt;Config&gt; = {
  host: "localhost", // agora obrigat√≥rio
  port: 3000         // agora obrigat√≥rio
};</code></pre>

  <h4>Readonly&lt;T&gt;</h4>
  <p><strong>O que √©:</strong> torna todas as propriedades somente leitura.</p>
  <pre><code>const usuario: Readonly&lt;Usuario&gt; = {
  nome: "Ana",
  email: "ana@email.com",
  idade: 25
};

// usuario.nome = "Maria"; // ‚ùå ERRO: n√£o pode modificar</code></pre>

  <h4>Pick&lt;T, K&gt;</h4>
  <p><strong>O que √©:</strong> cria tipo com apenas propriedades selecionadas.</p>
  <pre><code>type UsuarioBasico = Pick&lt;Usuario, "nome" | "email"&gt;;
// { nome: string; email: string; }</code></pre>

  <h4>Omit&lt;T, K&gt;</h4>
  <p><strong>O que √©:</strong> cria tipo removendo propriedades espec√≠ficas.</p>
  <pre><code>type UsuarioSemIdade = Omit&lt;Usuario, "idade"&gt;;
// { nome: string; email: string; }</code></pre>

  <h4>Record&lt;K, T&gt;</h4>
  <p><strong>O que √©:</strong> cria objeto com chaves K e valores T.</p>
  <pre><code>type Notas = Record&lt;string, number&gt;;

const notasAlunos: Notas = {
  "Jo√£o": 8.5,
  "Maria": 9.0,
  "Pedro": 7.5
};</code></pre>

  <h4>Exclude&lt;T, U&gt; e Extract&lt;T, U&gt;</h4>
  <pre><code>type Cor = "vermelho" | "verde" | "azul" | "amarelo";

type CoresQuentes = Exclude&lt;Cor, "verde" | "azul"&gt;;
// "vermelho" | "amarelo"

type CoresFrias = Extract&lt;Cor, "verde" | "azul"&gt;;
// "verde" | "azul"</code></pre>

  <h4>ReturnType&lt;T&gt; e Parameters&lt;T&gt;</h4>
  <p><strong>O que √©:</strong> extrai tipo de retorno ou par√¢metros de fun√ß√£o.</p>
  <pre><code>function criar(nome: string, idade: number) {
  return { nome, idade };
}

type Retorno = ReturnType&lt;typeof criar&gt;;
// { nome: string; idade: number; }

type Params = Parameters&lt;typeof criar&gt;;
// [string, number]</code></pre>
</section>

<section id="ts-decorators" class="topic">
  <h3>Decorators</h3>
  <p><strong>O que √©:</strong> fun√ß√µes especiais que modificam classes, m√©todos ou propriedades (feature experimental).</p>
  <p><strong>Por que usar:</strong> adicionar metadados, valida√ß√£o, logging etc de forma declarativa.</p>
  <p class="small-note">
    ‚ö†Ô∏è Decorators s√£o experimentais. Habilite no tsconfig.json: <code>"experimentalDecorators": true</code>
  </p>

  <h4>Class Decorator</h4>
  <pre><code>// Decorator que adiciona timestamp
function Timestamped(constructor: Function) {
  constructor.prototype.timestamp = new Date();
}

@Timestamped
class Pessoa {
  constructor(public nome: string) {}
}

const p = new Pessoa("Jo√£o");
console.log((p as any).timestamp);</code></pre>

  <h4>Method Decorator</h4>
  <pre><code>function Log(
  target: any,
  propertyKey: string,
  descriptor: PropertyDescriptor
) {
  const metodoOriginal = descriptor.value;

  descriptor.value = function (...args: any[]) {
    console.log(`Chamando ${propertyKey} com:`, args);
    const resultado = metodoOriginal.apply(this, args);
    console.log(`Resultado:`, resultado);
    return resultado;
  };
}

class Calculadora {
  @Log
  somar(a: number, b: number) {
    return a + b;
  }
}

const calc = new Calculadora();
calc.somar(2, 3); // Loga automaticamente</code></pre>

  <h4>Property Decorator</h4>
  <pre><code>function MinLength(min: number) {
  return function (target: any, propertyKey: string) {
    let valor: string;

    const getter = () => valor;
    const setter = (novoValor: string) => {
      if (novoValor.length < min) {
        throw new Error(`${propertyKey} deve ter pelo menos ${min} caracteres`);
      }
      valor = novoValor;
    };

    Object.defineProperty(target, propertyKey, {
      get: getter,
      set: setter
    });
  };
}

class Usuario {
  @MinLength(3)
  nome: string = "";
}

const u = new Usuario();
// u.nome = "Jo"; // ‚ùå Erro: deve ter pelo menos 3 caracteres
u.nome = "Jo√£o"; // ‚úÖ OK</code></pre>
</section>

<section id="ts-config" class="topic">
  <h3>tsconfig.json</h3>
  <p><strong>O que √©:</strong> arquivo de configura√ß√£o do TypeScript que define como o compilador deve funcionar.</p>
  <p><strong>Por que usar:</strong> controla rigorosidade, m√≥dulos, target, e outras op√ß√µes importantes.</p>

  <h4>Configura√ß√£o b√°sica</h4>
  <pre><code>{
  "compilerOptions": {
    // Vers√£o do JavaScript gerado
    "target": "ES2020",

    // Sistema de m√≥dulos
    "module": "ESNext",
    "moduleResolution": "node",

    // Diret√≥rios
    "outDir": "./dist",          // onde salvar .js compilados
    "rootDir": "./src",           // onde est√£o os .ts

    // Qualidade e rigorosidade
    "strict": true,               // ativa todas checagens estritas
    "noImplicitAny": true,        // erro se tipo for 'any' impl√≠cito
    "strictNullChecks": true,     // null e undefined s√£o tipos separados
    "strictFunctionTypes": true,

    // Recursos extras
    "esModuleInterop": true,      // compatibilidade com imports
    "skipLibCheck": true,         // pula checagem de arquivos .d.ts
    "forceConsistentCasingInFileNames": true,

    // Source maps (para debug)
    "sourceMap": true,

    // Permite JSON imports
    "resolveJsonModule": true
  },

  "include": ["src/**/*"],        // arquivos para compilar
  "exclude": ["node_modules"]     // arquivos para ignorar
}</code></pre>

  <h4>Op√ß√µes importantes</h4>
  <pre><code>{
  "compilerOptions": {
    // Decorators (Angular, NestJS, etc)
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,

    // JSX (React)
    "jsx": "react-jsx",

    // Permite JS junto com TS
    "allowJs": true,
    "checkJs": true,

    // Remove coment√°rios do output
    "removeComments": true,

    // N√£o emite arquivos se houver erro
    "noEmitOnError": true,

    // Path aliases (imports curtos)
    "baseUrl": ".",
    "paths": {
      "@components/*": ["src/components/*"],
      "@utils/*": ["src/utils/*"]
    }
  }
}</code></pre>

  <h4>Configura√ß√µes por ambiente</h4>
  <pre><code>// tsconfig.json (base)
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "strict": true
  }
}

// tsconfig.build.json (produ√ß√£o)
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "sourceMap": false,
    "removeComments": true
  }
}

// tsconfig.test.json (testes)
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "types": ["jest", "node"]
  }
}</code></pre>

  <h4>Targets mais comuns</h4>
  <ul>
    <li><code>"ES5"</code> ‚Äì compat√≠vel com IE11 (antigo)</li>
    <li><code>"ES6"/"ES2015"</code> ‚Äì navegadores modernos b√°sicos</li>
    <li><code>"ES2020"</code> ‚Äì navegadores recentes (recomendado)</li>
    <li><code>"ESNext"</code> ‚Äì recursos mais novos dispon√≠veis</li>
  </ul>
</section>

<section id="ts-boas-praticas" class="topic">
  <h3>Boas pr√°ticas</h3>
  <p><strong>O que √©:</strong> conven√ß√µes e padr√µes para escrever TypeScript de qualidade.</p>
  <p><strong>Por que usar:</strong> c√≥digo mais leg√≠vel, manuten√≠vel e menos propenso a bugs.</p>

  <h4>1. Evite 'any' sempre que poss√≠vel</h4>
  <pre><code>// ‚ùå EVITE
function processar(dados: any) {
  return dados.valor;
}

// ‚úÖ PREFIRA
interface Dados {
  valor: number;
}

function processar(dados: Dados) {
  return dados.valor;
}

// Se realmente n√£o sabe o tipo, use 'unknown'
function processar(dados: unknown) {
  if (typeof dados === "object" && dados !== null) {
    // TypeScript te for√ßa a checar o tipo
  }
}</code></pre>

  <h4>2. Use interfaces para objetos, types para uni√µes</h4>
  <pre><code>// ‚úÖ Interface para objetos (podem ser estendidas)
interface Usuario {
  nome: string;
  email: string;
}

interface UsuarioAdmin extends Usuario {
  nivel: number;
}

// ‚úÖ Type para uni√µes, literais, aliases
type Status = "ativo" | "inativo" | "pendente";
type ID = string | number;</code></pre>

  <h4>3. Seja espec√≠fico com tipos</h4>
  <pre><code>// ‚ùå GEN√âRICO DEMAIS
function buscar(id: string): object {
  return { id, nome: "Jo√£o" };
}

// ‚úÖ ESPEC√çFICO
interface Usuario {
  id: string;
  nome: string;
}

function buscar(id: string): Usuario {
  return { id, nome: "Jo√£o" };
}</code></pre>

  <h4>4. Use readonly quando apropriado</h4>
  <pre><code>interface Config {
  readonly apiUrl: string;
  readonly timeout: number;
}

const config: Config = {
  apiUrl: "https://api.exemplo.com",
  timeout: 5000
};

// config.apiUrl = "outro"; // ‚ùå ERRO</code></pre>

  <h4>5. Prefira const assertions para literais</h4>
  <pre><code>// ‚ùå tipo ser√° string[]
const cores = ["vermelho", "verde", "azul"];

// ‚úÖ tipo ser√° readonly ["vermelho", "verde", "azul"]
const cores = ["vermelho", "verde", "azul"] as const;

// √ötil para objetos tamb√©m
const config = {
  host: "localhost",
  port: 3000
} as const;</code></pre>

  <h4>6. Use optional chaining e nullish coalescing</h4>
  <pre><code>// ‚úÖ Optional chaining (?.)
const nome = usuario?.endereco?.rua;

// ‚úÖ Nullish coalescing (??)
const porta = config.port ?? 3000;

// ‚ùå EVITE
const nome = usuario && usuario.endereco && usuario.endereco.rua;
const porta = config.port || 3000; // problema: 0 √© falsy!</code></pre>

  <h4>7. Organize imports</h4>
  <pre><code>// ‚úÖ BOA ORGANIZA√á√ÉO
// 1. Bibliotecas externas
import { useState, useEffect } from "react";
import axios from "axios";

// 2. Arquivos internos (paths absolutos)
import { Button } from "@components/Button";
import { formatarData } from "@utils/data";

// 3. Tipos
import type { Usuario } from "@types/usuario";

// 4. Estilos
import "./styles.css";</code></pre>

  <h4>8. Documente tipos complexos</h4>
  <pre><code>/**
 * Representa um usu√°rio do sistema
 * @property id - Identificador √∫nico
 * @property nome - Nome completo
 * @property role - Papel do usu√°rio (admin, user, guest)
 */
interface Usuario {
  id: string;
  nome: string;
  role: "admin" | "user" | "guest";
}

/**
 * Busca usu√°rio por ID
 * @param id - ID do usu√°rio
 * @returns Promise com dados do usu√°rio ou null se n√£o encontrado
 */
async function buscarUsuario(id: string): Promise&lt;Usuario | null&gt; {
  // implementa√ß√£o
}</code></pre>

  <h4>9. Use enums para constantes relacionadas</h4>
  <pre><code>// ‚úÖ Enum para status
enum StatusPedido {
  Pendente = "PENDENTE",
  Processando = "PROCESSANDO",
  Enviado = "ENVIADO",
  Entregue = "ENTREGUE",
  Cancelado = "CANCELADO"
}

function atualizarStatus(pedidoId: string, status: StatusPedido) {
  // TypeScript garante que s√≥ valores v√°lidos sejam passados
}

atualizarStatus("123", StatusPedido.Enviado);</code></pre>

  <h4>10. Configure linter (ESLint + TypeScript)</h4>
  <pre><code>// .eslintrc.json
{
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended"
  ],
  "parser": "@typescript-eslint/parser",
  "plugins": ["@typescript-eslint"],
  "rules": {
    "@typescript-eslint/no-explicit-any": "error",
    "@typescript-eslint/explicit-function-return-type": "warn"
  }
}</code></pre>

  <h4>Resumo das boas pr√°ticas</h4>
  <ul>
    <li>‚úÖ Ative <code>"strict": true</code> no tsconfig.json</li>
    <li>‚úÖ Evite <code>any</code>, use <code>unknown</code> quando necess√°rio</li>
    <li>‚úÖ Seja espec√≠fico com tipos de retorno de fun√ß√µes</li>
    <li>‚úÖ Use <code>readonly</code> para dados imut√°veis</li>
    <li>‚úÖ Prefira interfaces para objetos</li>
    <li>‚úÖ Use type guards em vez de type assertions</li>
    <li>‚úÖ Documente c√≥digo complexo com JSDoc</li>
    <li>‚úÖ Configure ESLint para TypeScript</li>
    <li>‚úÖ Use utility types (Partial, Pick, Omit etc)</li>
    <li>‚úÖ Organize imports de forma consistente</li>
  </ul>
</section>
