<section id="ts-intro" class="topic active">
  <h2>‚öôÔ∏è TypeScript ‚Äî Tipos, POO, Generics e DOM</h2>

  <div class="mini-index">
    <strong>Nesta se√ß√£o voc√™ encontra:</strong>
    Introdu√ß√£o ¬∑ Tipos b√°sicos ¬∑ Any / unknown / never ¬∑ Union, literal, enum ¬∑ Objetos e interfaces ¬∑ Fun√ß√µes ¬∑
    Classes e heran√ßa ¬∑ Generics ¬∑ Narrowing ¬∑ Utility types ¬∑ DOM com TS ¬∑ M√≥dulos ¬∑ Async/await ¬∑ Try/catch ¬∑ tsconfig.json ¬∑ Boas pr√°ticas.
  </div>

  <h3>Introdu√ß√£o</h3>
  <p><strong>O que √©:</strong> TypeScript √© um ‚Äúsuperconjunto‚Äù do JavaScript, ou seja, tudo que existe em JS existe em TS, com o extra de tipagem est√°tica.</p>
  <p><strong>Por que usar:</strong> encontrar erros mais cedo, deixar o c√≥digo mais previs√≠vel e facilitar manuten√ß√£o em projetos grandes.</p>

  <pre><code>// Instalar TypeScript globalmente (via npm):
// npm install -g typescript

// Compilar arquivo:
// tsc arquivo.ts</code></pre>
</section>

<section id="ts-tipos-basicos" class="topic">
  <h3>Tipos b√°sicos</h3>

  <h4>Primitivos</h4>
  <p><strong>O que √©:</strong> tipos mais simples: <code>string</code>, <code>number</code>, <code>boolean</code> etc.</p>
  <p><strong>Por que usar:</strong> deixam claro que tipo de dado voc√™ espera e evita usar valores errados.</p>

  <pre><code>let nome: string = "Ana";
let idade: number = 25;
let ativo: boolean = true;

let numeros: number[] = [1, 2, 3];
let nomes: string[] = ["Ana", "Jo√£o"];</code></pre>

  <h4>Any, unknown e never</h4>
  <p><strong>O que √©:</strong> tipos especiais para casos espec√≠ficos.</p>
  <ul>
    <li><strong>any</strong> ‚Äì desliga a checagem de tipo (aceita qualquer coisa);</li>
    <li><strong>unknown</strong> ‚Äì parecido com any, mas obriga checar antes de usar;</li>
    <li><strong>never</strong> ‚Äì fun√ß√£o que nunca retorna (erro ou loop infinito).</li>
  </ul>
  <p><strong>Por que usar:</strong> s√≥ quando necess√°rio: <code>unknown</code> para dados externos, <code>never</code> para fun√ß√µes que sempre lan√ßam erro.</p>

  <pre><code>let algo: any = "teste";   // foge da tipagem, use com cuidado
algo = 123;

let seguro: unknown = "oi"; // mais seguro que any
if (typeof seguro === "string") {
  console.log(seguro.toUpperCase());
}

function erro(msg: string): never {
  throw new Error(msg);
}</code></pre>

  <h4>Union types e type alias</h4>
  <p><strong>O que √©:</strong> forma de dizer que algo pode ser de mais de um tipo e dar um nome para esse conjunto.</p>
  <p><strong>Por que usar:</strong> ajuda a modelar casos em que um valor pode ter mais de uma forma (ex.: id num√©rico ou string).</p>

  <pre><code>type ID = string | number;

let idUsuario: ID = 42;
idUsuario = "abc";

// literal types
type Status = "ativo" | "inativo";

let statusUsuario: Status = "ativo";
// statusUsuario = "pendente"; // erro</code></pre>

  <h4>Enum</h4>
  <p><strong>O que √©:</strong> conjunto de valores nomeados.</p>
  <p><strong>Por que usar:</strong> substitui strings soltas e evita erros de digita√ß√£o.</p>

  <pre><code>enum Cor {
  Vermelho = "vermelho",
  Verde = "verde",
  Azul = "azul"
}

let corEscolhida: Cor = Cor.Vermelho;</code></pre>
</section>

<section id="ts-objetos-interfaces" class="topic">
  <h3>Objetos, interfaces e tipos compostos</h3>

  <h4>Objetos tipados</h4>
  <p><strong>O que √©:</strong> declarar a forma de um objeto (quais propriedades ele tem).</p>
  <p><strong>Por que usar:</strong> evita acessar propriedades inexistentes e documenta os dados.</p>

  <pre><code>let usuario: {
  nome: string;
  idade: number;
  email?: string; // opcional
} = {
  nome: "Maria",
  idade: 30
};</code></pre>

  <h4>Interfaces</h4>
  <p><strong>O que √©:</strong> uma forma reutiliz√°vel de descrever objetos.</p>
  <p><strong>Por que usar:</strong> deixa o c√≥digo mais organizado, principalmente ao trabalhar com fun√ß√µes e classes.</p>

  <pre><code>interface Usuario {
  nome: string;
  idade: number;
  email?: string;
}

const u1: Usuario = {
  nome: "Ana",
  idade: 22
};</code></pre>

  <h4>Extens√£o de interfaces</h4>
  <p><strong>O que √©:</strong> uma interface herdando campos de outra.</p>
  <p><strong>Por que usar:</strong> reaproveitar estruturas comuns, evitando repeti√ß√£o.</p>

  <pre><code>interface Pessoa {
  nome: string;
}

interface Funcionario extends Pessoa {
  cargo: string;
}

const f1: Funcionario = {
  nome: "Jo√£o",
  cargo: "Desenvolvedor"
};</code></pre>

  <h4>Intersection types</h4>
  <p><strong>O que √©:</strong> combina√ß√£o de tipos usando <code>&amp;</code>.</p>
  <p><strong>Por que usar:</strong> quando voc√™ precisa de algo que tenha as propriedades de dois tipos ao mesmo tempo.</p>

  <pre><code>type ComID = { id: number };
type Produto = { nome: string; preco: number };

type ProdutoComID = Produto & ComID;

const prod: ProdutoComID = {
  id: 1,
  nome: "Mouse",
  preco: 50
};</code></pre>
</section>

<section id="ts-funcoes" class="topic">
  <h3>Fun√ß√µes</h3>

  <h4>Par√¢metros e retorno tipados</h4>
  <p><strong>O que √©:</strong> declarar o tipo dos par√¢metros e do resultado.</p>
  <p><strong>Por que usar:</strong> impede passar tipos errados para a fun√ß√£o e torna o c√≥digo autoexplicativo.</p>

  <pre><code>function somar(a: number, b: number): number {
  return a + b;
}

function logar(mensagem: string): void {
  console.log(mensagem);
}</code></pre>

  <h4>Fun√ß√µes an√¥nimas e arrow functions</h4>
  <p><strong>O que √©:</strong> formas curtas de declarar fun√ß√µes.</p>
  <p><strong>Por que usar:</strong> muito usadas em callbacks e c√≥digo moderno (React, etc.).</p>

  <pre><code>const multiplicar = (a: number, b: number): number =&gt; a * b;

const saudar = (nome: string): string =&gt; `Ol√°, ${nome}!`;</code></pre>

  <h4>Par√¢metros opcionais e padr√£o</h4>
  <p><strong>O que √©:</strong> par√¢metros que podem estar ausentes e valores padr√£o.</p>
  <p><strong>Por que usar:</strong> torna fun√ß√µes mais flex√≠veis, sem precisar criar v√°rias vers√µes.</p>

  <pre><code>function apresentar(nome: string, idade?: number): string {
  if (idade) {
    return `Meu nome √© ${nome} e tenho ${idade} anos.`;
  }
  return `Meu nome √© ${nome}.`;
}

function aplicarDesconto(preco: number, desconto: number = 0.1): number {
  return preco - preco * desconto;
}</code></pre>
</section>

<section id="ts-classes" class="topic">
  <h3>Classes, POO e heran√ßa</h3>

  <h4>Classe b√°sica</h4>
  <p><strong>O que √©:</strong> molde para criar objetos com dados (propriedades) e comportamento (m√©todos).</p>
  <p><strong>Por que usar:</strong> ajuda a organizar c√≥digo orientado a objetos, principalmente em apps grandes.</p>

  <pre><code>class Pessoa {
  constructor(public nome: string, public idade: number) {}

  apresentar(): string {
    return `Eu sou ${this.nome} e tenho ${this.idade} anos.`;
  }
}

const p = new Pessoa("Carlos", 28);
console.log(p.apresentar());</code></pre>

  <h4>Modificadores de acesso</h4>
  <p><strong>O que √©:</strong> palavras-chave que controlam quem pode acessar propriedades/m√©todos.</p>
  <ul>
    <li><code>public</code> ‚Äì acess√≠vel de qualquer lugar;</li>
    <li><code>private</code> ‚Äì acess√≠vel s√≥ dentro da pr√≥pria classe;</li>
    <li><code>protected</code> ‚Äì acess√≠vel na classe e em quem herda dela.</li>
  </ul>

  <pre><code>class ContaBancaria {
  public titular: string;
  private saldo: number;

  constructor(titular: string, saldoInicial: number) {
    this.titular = titular;
    this.saldo = saldoInicial;
  }

  public depositar(valor: number): void {
    this.saldo += valor;
  }

  public getSaldo(): number {
    return this.saldo;
  }
}</code></pre>

  <h4>Classes abstratas e heran√ßa</h4>
  <p><strong>O que √©:</strong> classes que n√£o podem ser instanciadas diretamente e servem de base para outras.</p>
  <p><strong>Por que usar:</strong> definir contratos e comportamentos que subclasses devem implementar.</p>

  <pre><code>abstract class Forma {
  abstract calcularArea(): number;
}

class Retangulo extends Forma {
  constructor(public largura: number, public altura: number) {
    super();
  }

  calcularArea(): number {
    return this.largura * this.altura;
  }
}

const r = new Retangulo(10, 5);
console.log(r.calcularArea()); // 50</code></pre>
</section>

<section id="ts-generics" class="topic">
  <h3>Generics e recursos avan√ßados</h3>

  <h4>Fun√ß√µes gen√©ricas</h4>
  <p><strong>O que √©:</strong> fun√ß√µes que funcionam com v√°rios tipos, mas ainda assim s√£o tipadas.</p>
  <p><strong>Por que usar:</strong> evita duplicar c√≥digo para cada tipo diferente.</p>

  <pre><code>function primeiroElemento&lt;T&gt;(array: T[]): T | undefined {
  return array[0];
}

const n = primeiroElemento&lt;number&gt;([1, 2, 3]);
const s = primeiroElemento&lt;string&gt;(["a", "b"]);
// n √© number | undefined, s √© string | undefined</code></pre>

  <h4>Interfaces gen√©ricas</h4>
  <p><strong>O que √©:</strong> interfaces que recebem tipos como par√¢metro.</p>
  <p><strong>Por que usar:</strong> muito √∫til para respostas de API, cole√ß√µes, etc.</p>

  <pre><code>interface RespostaAPI&lt;T&gt; {
  dados: T;
  status: number;
  mensagem?: string;
}

interface UsuarioAPI {
  nome: string;
  idade: number;
}

const resp: RespostaAPI&lt;UsuarioAPI&gt; = {
  dados: { nome: "Ana", idade: 25 },
  status: 200
};</code></pre>

  <h4>Narrowing e tipos especiais</h4>
  <p><strong>O que √©:</strong> quando o TypeScript ‚Äúafina‚Äù o tipo baseado em checagens que voc√™ faz.</p>
  <p><strong>Por que usar:</strong> te permite trabalhar com tipos union de forma segura.</p>

  <pre><code>function imprimirId(id: string | number) {
  if (typeof id === "string") {
    console.log(id.toUpperCase());
  } else {
    console.log(id.toFixed(2));
  }
}</code></pre>

  <h4>Utility types importantes</h4>
  <p><strong>O que √©:</strong> tipos prontos que transformam outros tipos.</p>
  <p><strong>Por que usar:</strong> evitam criar varia√ß√µes de tipos na m√£o.</p>

  <pre><code>interface Usuario {
  nome: string;
  idade: number;
  email: string;
}

/* Torna todas as propriedades opcionais */
type UsuarioParcial = Partial&lt;Usuario&gt;;

/* Torna todas obrigat√≥rias */
type UsuarioCompleto = Required&lt;Usuario&gt;;

/* Pega s√≥ algumas propriedades */
type UsuarioPublico = Pick&lt;Usuario, "nome" | "email"&gt;;

/* Remove algumas propriedades */
type UsuarioSemEmail = Omit&lt;Usuario, "email"&gt;;

/* Record: mapa de chaves para um tipo */
type MapaUsuarios = Record&lt;string, Usuario&gt;;

/* Readonly: n√£o pode alterar propriedades */
type UsuarioReadonly = Readonly&lt;Usuario&gt;;</code></pre>

  <h4>keyof e indexed access</h4>
  <p><strong>O que √©:</strong> <code>keyof</code> pega as chaves de um tipo como uni√£o de strings.</p>
  <p><strong>Por que usar:</strong> permite criar fun√ß√µes gen√©ricas que acessam propriedades de forma segura.</p>

  <pre><code>type ChavesUsuario = keyof Usuario; // "nome" | "idade" | "email"

function pegarPropriedade(
  usuario: Usuario,
  chave: ChavesUsuario
) {
  return usuario[chave];
}</code></pre>
</section>

<section id="ts-type-guards" class="topic">
  <h3>Type Guards e Narrowing</h3>
  <p><strong>O que √©:</strong> t√©cnicas para refinar tipos em tempo de execu√ß√£o, permitindo TypeScript entender melhor o c√≥digo.</p>
  <p><strong>Por que usar:</strong> torna o c√≥digo mais seguro e elimina a necessidade de type assertions (as).</p>

  <h4>Typeof guard</h4>
  <pre><code>function processar(valor: string | number) {
  if (typeof valor === "string") {
    // TypeScript sabe que aqui √© string
    return valor.toUpperCase();
  } else {
    // TypeScript sabe que aqui √© number
    return valor.toFixed(2);
  }
}</code></pre>

  <h4>Instanceof guard</h4>
  <pre><code>class Cachorro {
  latir() { console.log("Au au!"); }
}

class Gato {
  miar() { console.log("Miau!"); }
}

function fazerBarulho(animal: Cachorro | Gato) {
  if (animal instanceof Cachorro) {
    animal.latir();
  } else {
    animal.miar();
  }
}</code></pre>

  <h4>In operator (checar propriedade)</h4>
  <pre><code>interface Carro {
  dirigir(): void;
}

interface Barco {
  navegar(): void;
}

function mover(veiculo: Carro | Barco) {
  if ("dirigir" in veiculo) {
    veiculo.dirigir();
  } else {
    veiculo.navegar();
  }
}</code></pre>

  <h4>Type predicate (custom guard)</h4>
  <p><strong>O que √©:</strong> fun√ß√£o que retorna <code>valor is Tipo</code> para criar guards customizados.</p>
  <pre><code>interface Peixe {
  nadar(): void;
}

interface Passaro {
  voar(): void;
}

// Type predicate
function isPeixe(animal: Peixe | Passaro): animal is Peixe {
  return (animal as Peixe).nadar !== undefined;
}

function moverAnimal(animal: Peixe | Passaro) {
  if (isPeixe(animal)) {
    animal.nadar();
  } else {
    animal.voar();
  }
}</code></pre>

  <h4>Discriminated unions</h4>
  <p><strong>O que √©:</strong> usar uma propriedade comum para diferenciar tipos.</p>
  <pre><code>interface Circulo {
  tipo: "circulo";
  raio: number;
}

interface Retangulo {
  tipo: "retangulo";
  largura: number;
  altura: number;
}

type Forma = Circulo | Retangulo;

function calcularArea(forma: Forma) {
  switch (forma.tipo) {
    case "circulo":
      return Math.PI * forma.raio ** 2;
    case "retangulo":
      return forma.largura * forma.altura;
  }
}</code></pre>
</section>

<section id="ts-utility-types" class="topic">
  <h3>Utility Types avan√ßados</h3>
  <p><strong>O que √©:</strong> tipos utilit√°rios embutidos no TypeScript para transformar tipos existentes.</p>
  <p><strong>Por que usar:</strong> evita repeti√ß√£o e torna c√≥digo mais flex√≠vel.</p>

  <h4>Partial&lt;T&gt;</h4>
  <p><strong>O que √©:</strong> torna todas as propriedades opcionais.</p>
  <pre><code>interface Usuario {
  nome: string;
  email: string;
  idade: number;
}

// Partial permite passar apenas algumas propriedades
function atualizarUsuario(id: number, dados: Partial&lt;Usuario&gt;) {
  // pode passar s√≥ { nome: "Jo√£o" } sem email e idade
}

atualizarUsuario(1, { nome: "Jo√£o" });</code></pre>

  <h4>Required&lt;T&gt;</h4>
  <p><strong>O que √©:</strong> torna todas as propriedades obrigat√≥rias.</p>
  <pre><code>interface Config {
  host?: string;
  port?: number;
}

const configCompleta: Required&lt;Config&gt; = {
  host: "localhost", // agora obrigat√≥rio
  port: 3000         // agora obrigat√≥rio
};</code></pre>

  <h4>Readonly&lt;T&gt;</h4>
  <p><strong>O que √©:</strong> torna todas as propriedades somente leitura.</p>
  <pre><code>const usuario: Readonly&lt;Usuario&gt; = {
  nome: "Ana",
  email: "ana@email.com",
  idade: 25
};

// usuario.nome = "Maria"; // ‚ùå ERRO: n√£o pode modificar</code></pre>

  <h4>Pick&lt;T, K&gt;</h4>
  <p><strong>O que √©:</strong> cria tipo com apenas propriedades selecionadas.</p>
  <pre><code>type UsuarioBasico = Pick&lt;Usuario, "nome" | "email"&gt;;
// { nome: string; email: string; }</code></pre>

  <h4>Omit&lt;T, K&gt;</h4>
  <p><strong>O que √©:</strong> cria tipo removendo propriedades espec√≠ficas.</p>
  <pre><code>type UsuarioSemIdade = Omit&lt;Usuario, "idade"&gt;;
// { nome: string; email: string; }</code></pre>

  <h4>Record&lt;K, T&gt;</h4>
  <p><strong>O que √©:</strong> cria objeto com chaves K e valores T.</p>
  <pre><code>type Notas = Record&lt;string, number&gt;;

const notasAlunos: Notas = {
  "Jo√£o": 8.5,
  "Maria": 9.0,
  "Pedro": 7.5
};</code></pre>

  <h4>Exclude&lt;T, U&gt; e Extract&lt;T, U&gt;</h4>
  <pre><code>type Cor = "vermelho" | "verde" | "azul" | "amarelo";

type CoresQuentes = Exclude&lt;Cor, "verde" | "azul"&gt;;
// "vermelho" | "amarelo"

type CoresFrias = Extract&lt;Cor, "verde" | "azul"&gt;;
// "verde" | "azul"</code></pre>

  <h4>ReturnType&lt;T&gt; e Parameters&lt;T&gt;</h4>
  <p><strong>O que √©:</strong> extrai tipo de retorno ou par√¢metros de fun√ß√£o.</p>
  <pre><code>function criar(nome: string, idade: number) {
  return { nome, idade };
}

type Retorno = ReturnType&lt;typeof criar&gt;;
// { nome: string; idade: number; }

type Params = Parameters&lt;typeof criar&gt;;
// [string, number]</code></pre>
</section>

<section id="ts-decorators" class="topic">
  <h3>Decorators</h3>
  <p><strong>O que √©:</strong> fun√ß√µes especiais que modificam classes, m√©todos ou propriedades (feature experimental).</p>
  <p><strong>Por que usar:</strong> adicionar metadados, valida√ß√£o, logging etc de forma declarativa.</p>
  <p class="small-note">
    ‚ö†Ô∏è Decorators s√£o experimentais. Habilite no tsconfig.json: <code>"experimentalDecorators": true</code>
  </p>

  <h4>Class Decorator</h4>
  <pre><code>// Decorator que adiciona timestamp
function Timestamped(constructor: Function) {
  constructor.prototype.timestamp = new Date();
}

@Timestamped
class Pessoa {
  constructor(public nome: string) {}
}

const p = new Pessoa("Jo√£o");
console.log((p as any).timestamp);</code></pre>

  <h4>Method Decorator</h4>
  <pre><code>function Log(
  target: any,
  propertyKey: string,
  descriptor: PropertyDescriptor
) {
  const metodoOriginal = descriptor.value;

  descriptor.value = function (...args: any[]) {
    console.log(`Chamando ${propertyKey} com:`, args);
    const resultado = metodoOriginal.apply(this, args);
    console.log(`Resultado:`, resultado);
    return resultado;
  };
}

class Calculadora {
  @Log
  somar(a: number, b: number) {
    return a + b;
  }
}

const calc = new Calculadora();
calc.somar(2, 3); // Loga automaticamente</code></pre>

  <h4>Property Decorator</h4>
  <pre><code>function MinLength(min: number) {
  return function (target: any, propertyKey: string) {
    let valor: string;

    const getter = () => valor;
    const setter = (novoValor: string) => {
      if (novoValor.length < min) {
        throw new Error(`${propertyKey} deve ter pelo menos ${min} caracteres`);
      }
      valor = novoValor;
    };

    Object.defineProperty(target, propertyKey, {
      get: getter,
      set: setter
    });
  };
}

class Usuario {
  @MinLength(3)
  nome: string = "";
}

const u = new Usuario();
// u.nome = "Jo"; // ‚ùå Erro: deve ter pelo menos 3 caracteres
u.nome = "Jo√£o"; // ‚úÖ OK</code></pre>
</section>

<section id="ts-dom" class="topic">
  <h3>DOM + TypeScript</h3>

  <p><strong>O que √©:</strong> intera√ß√£o com elementos da p√°gina (inputs, bot√µes, etc.) com o TypeScript sabendo os tipos.</p>
  <p><strong>Por que usar:</strong> evita acessar propriedades incorretas e te d√° autocomplete no editor.</p>

  <pre><code>// querySelector: busca elemento por seletor CSS (retorna Element | null)
const titulo = document.querySelector("h1");

// Sempre checar se existe (pode ser null)
if (titulo) {
  // textContent: altera o texto dentro do elemento
  titulo.textContent = "T√≠tulo atualizado com TS!";
}

// getElementById: busca por ID
// "as HTMLInputElement": informa ao TypeScript o tipo espec√≠fico do elemento
const inputNome = document.getElementById("nome") as HTMLInputElement;
const botao = document.getElementById("btn") as HTMLButtonElement;

// addEventListener: adiciona evento de clique
botao.addEventListener("click", () =&gt; {
  // value: propriedade que s√≥ existe em inputs (por isso precisamos do "as")
  alert(`Voc√™ digitou: ${inputNome.value}`);
});</code></pre>

  <p class="small-note">
    Em projetos reais, voc√™ normalmente usa TS com bundlers (Vite, Webpack) ou frameworks como React/Angular.
  </p>
</section>

<section id="ts-modulos" class="topic">
  <h3>M√≥dulos e organiza√ß√£o</h3>

  <p><strong>O que √©:</strong> dividir o c√≥digo em arquivos com <code>export</code> e <code>import</code>.</p>
  <p><strong>Por que usar:</strong> mant√©m o projeto organizado e evita vari√°veis globais.</p>

  <pre><code>// ========== utils.ts ==========
// export: torna fun√ß√£o/vari√°vel dispon√≠vel para outros arquivos
export function somar(a: number, b: number): number {
  return a + b;
}

export const PI = 3.14159;

// ========== app.ts ==========
// import: traz fun√ß√µes/vari√°veis de outro arquivo
// { somar, PI }: importa√ß√£o nomeada (destructuring)
// "./utils": caminho do arquivo (sem .ts)
import { somar, PI } from "./utils";

console.log(somar(2, 3)); // 5
console.log(PI);          // 3.14159</code></pre>
</section>

<section id="ts-async" class="topic">
  <h3>Promises e async/await</h3>

  <p><strong>O que √©:</strong> forma moderna de lidar com c√≥digo ass√≠ncrono (que demora), como requisi√ß√µes a APIs.</p>
  <p><strong>Por que usar:</strong> deixa o c√≥digo muito mais leg√≠vel do que cadeias grandes de <code>.then()</code>.</p>

  <p><strong>Exemplo explicado:</strong></p>
  <ul>
    <li><code>function buscarDados(): Promise&lt;string&gt;</code> ‚Äì fun√ß√£o que devolve uma promessa de string;</li>
    <li><code>new Promise((resolve) =&gt; { ... })</code> ‚Äì cria manualmente uma Promise;</li>
    <li><code>setTimeout(..., 1000)</code> ‚Äì simula uma opera√ß√£o demorada (1 segundo);</li>
    <li><code>async function executar()</code> ‚Äì fun√ß√£o ass√≠ncrona que pode usar <code>await</code>;</li>
    <li><code>await buscarDados()</code> ‚Äì espera a Promise terminar e pega o resultado;</li>
    <li><code>try / catch</code> ‚Äì trata erros que podem acontecer durante a execu√ß√£o.</li>
  </ul>

  <pre><code>// Fun√ß√£o que retorna uma Promise (opera√ß√£o ass√≠ncrona)
function buscarDados(): Promise&lt;string&gt; {
  // new Promise: cria uma nova promessa
  return new Promise((resolve) =&gt; {
    // setTimeout: executa c√≥digo depois de X milissegundos
    setTimeout(() =&gt; {
      // resolve: marca a promessa como conclu√≠da com sucesso
      resolve("Dados recebidos!");
    }, 1000); // espera 1 segundo (1000ms)
  });
}

// async: permite usar await dentro da fun√ß√£o
async function executar() {
  try {
    // await: pausa execu√ß√£o at√© Promise completar
    const resultado = await buscarDados();
    console.log(resultado); // "Dados recebidos!"
  } catch (erro) {
    // catch: captura erros se algo der errado
    console.error("Erro:", erro);
  }
}

executar();</code></pre>

  <h4>Exemplo com fetch (API)</h4>
  <pre><code>// Define a estrutura dos dados que vamos receber
interface Post {
  userId: number;
  id: number;
  title: string;
  body: string;
}

async function carregarPosts() {
  // fetch: faz requisi√ß√£o HTTP para buscar dados
  const resposta = await fetch("https://jsonplaceholder.typicode.com/posts");

  // .json(): converte resposta para objeto JavaScript
  // Post[]: informa que √© um array de Posts
  const posts: Post[] = await resposta.json();

  // slice(0, 5): pega apenas os 5 primeiros
  // forEach: loop para cada item
  posts.slice(0, 5).forEach((post) =&gt; {
    console.log(post.title);
  });
}</code></pre>
</section>

<section id="ts-erros" class="topic">
  <h3>Tratamento de erros (try/catch)</h3>

  <p><strong>O que √©:</strong> mecanismo para capturar e tratar erros que podem acontecer durante a execu√ß√£o do c√≥digo.</p>
  <p><strong>Por que usar:</strong> previne que seu programa quebre completamente e permite lidar com situa√ß√µes inesperadas de forma controlada.</p>

  <h4>Try/Catch b√°sico</h4>
  <p><strong>Explica√ß√£o:</strong></p>
  <ul>
    <li><code>try { }</code> ‚Äì bloco onde voc√™ coloca c√≥digo que pode gerar erro;</li>
    <li><code>catch (erro) { }</code> ‚Äì bloco executado se algo der errado no try;</li>
    <li><code>finally { }</code> ‚Äì bloco que sempre executa, com ou sem erro.</li>
  </ul>

  <pre><code>function dividir(a: number, b: number): number {
  try {
    // C√≥digo que pode gerar erro
    if (b === 0) {
      throw new Error("N√£o √© poss√≠vel dividir por zero!");
    }
    return a / b;
  } catch (erro) {
    // Captura o erro e trata
    console.error("Erro ao dividir:", erro);
    return 0;
  } finally {
    // Sempre executa (opcional)
    console.log("Opera√ß√£o de divis√£o finalizada");
  }
}

console.log(dividir(10, 2));  // 5
console.log(dividir(10, 0));  // Erro capturado, retorna 0</code></pre>

  <h4>Tipos de erros</h4>
  <p><strong>O que √©:</strong> JavaScript/TypeScript tem diferentes tipos de erros nativos.</p>

  <pre><code>// Error gen√©rico
throw new Error("Algo deu errado");

// TypeError - tipo incorreto
throw new TypeError("Esperava um n√∫mero");

// RangeError - valor fora do alcance
throw new RangeError("N√∫mero deve ser entre 0 e 100");

// ReferenceError - vari√°vel n√£o existe
// (geralmente n√£o se lan√ßa manualmente)

// SyntaxError - erro de sintaxe
// (geralmente n√£o se lan√ßa manualmente)</code></pre>

  <h4>Criando erros customizados</h4>
  <p><strong>O que √©:</strong> criar suas pr√≥prias classes de erro para situa√ß√µes espec√≠ficas.</p>
  <p><strong>Por que usar:</strong> facilita identificar e tratar diferentes tipos de problema.</p>

  <pre><code>// Classe de erro customizada
class ValidacaoError extends Error {
  constructor(public campo: string, mensagem: string) {
    super(mensagem);
    this.name = "ValidacaoError";
  }
}

class AutenticacaoError extends Error {
  constructor(mensagem: string) {
    super(mensagem);
    this.name = "AutenticacaoError";
  }
}

// Usando erros customizados
function validarIdade(idade: number) {
  if (idade < 0) {
    throw new ValidacaoError("idade", "Idade n√£o pode ser negativa");
  }
  if (idade < 18) {
    throw new ValidacaoError("idade", "Voc√™ deve ter 18 anos ou mais");
  }
  return true;
}

try {
  validarIdade(-5);
} catch (erro) {
  if (erro instanceof ValidacaoError) {
    console.log(`Erro no campo ${erro.campo}: ${erro.message}`);
  }
}</code></pre>

  <h4>Try/Catch com async/await</h4>
  <p><strong>O que √©:</strong> capturar erros em opera√ß√µes ass√≠ncronas.</p>
  <p><strong>Por que usar:</strong> APIs podem falhar, conex√µes podem cair - sempre trate erros em opera√ß√µes ass√≠ncronas.</p>

  <pre><code>interface Usuario {
  id: number;
  nome: string;
  email: string;
}

async function buscarUsuario(id: number): Promise&lt;Usuario | null&gt; {
  try {
    // Faz requisi√ß√£o √† API
    const resposta = await fetch(`https://api.exemplo.com/usuarios/${id}`);

    // Verifica se a resposta foi bem-sucedida
    if (!resposta.ok) {
      throw new Error(`Erro HTTP: ${resposta.status}`);
    }

    // Converte para JSON
    const dados: Usuario = await resposta.json();
    return dados;

  } catch (erro) {
    // Trata diferentes tipos de erro
    if (erro instanceof TypeError) {
      console.error("Erro de rede ou JSON inv√°lido:", erro);
    } else if (erro instanceof Error) {
      console.error("Erro na requisi√ß√£o:", erro.message);
    }
    return null;
  }
}

// Usando a fun√ß√£o
async function exibirUsuario(id: number) {
  const usuario = await buscarUsuario(id);

  if (usuario) {
    console.log(`Usu√°rio: ${usuario.nome}`);
  } else {
    console.log("N√£o foi poss√≠vel carregar o usu√°rio");
  }
}</code></pre>

  <h4>Tratamento espec√≠fico por tipo de erro</h4>
  <pre><code>async function processarDados(url: string) {
  try {
    const resposta = await fetch(url);
    const dados = await resposta.json();
    return dados;

  } catch (erro) {
    // Verifica o tipo do erro e trata de forma diferente
    if (erro instanceof TypeError) {
      console.error("Erro de tipo ou rede:", erro.message);
      // Pode tentar novamente ou usar cache
    } else if (erro instanceof SyntaxError) {
      console.error("JSON inv√°lido:", erro.message);
      // Retornar dados padr√£o
    } else if (erro instanceof Error) {
      console.error("Erro gen√©rico:", erro.message);
    } else {
      // Erro desconhecido
      console.error("Erro desconhecido:", erro);
    }

    throw erro; // Re-lan√ßa o erro se necess√°rio
  }
}</code></pre>

  <h4>Finally - limpeza de recursos</h4>
  <p><strong>O que √©:</strong> bloco que sempre executa, independente de erro ou sucesso.</p>
  <p><strong>Por que usar:</strong> fechar conex√µes, limpar recursos, esconder loading, etc.</p>

  <pre><code>async function carregarDados() {
  const loading = document.getElementById("loading");

  try {
    // Mostra loading
    if (loading) loading.style.display = "block";

    const resposta = await fetch("https://api.exemplo.com/dados");
    const dados = await resposta.json();

    // Processa dados
    console.log(dados);

  } catch (erro) {
    console.error("Erro ao carregar:", erro);

  } finally {
    // SEMPRE esconde o loading, com erro ou sem
    if (loading) loading.style.display = "none";
  }
}</code></pre>

  <h4>Boas pr√°ticas com try/catch</h4>
  <ul>
    <li>‚úÖ Sempre trate erros em opera√ß√µes ass√≠ncronas (fetch, promises)</li>
    <li>‚úÖ Seja espec√≠fico: capture apenas erros que voc√™ sabe tratar</li>
    <li>‚úÖ Use erros customizados para situa√ß√µes espec√≠ficas do seu dom√≠nio</li>
    <li>‚úÖ Logue erros para debug, mas mostre mensagens amig√°veis ao usu√°rio</li>
    <li>‚úÖ Use <code>finally</code> para limpeza de recursos</li>
    <li>‚ùå N√£o deixe blocos catch vazios - sempre fa√ßa algo com o erro</li>
    <li>‚ùå N√£o use try/catch para controle de fluxo normal</li>
    <li>‚ùå N√£o capture tudo sem necessidade - deixe erros cr√≠ticos quebrarem</li>
  </ul>

  <h4>Exemplo completo com valida√ß√£o</h4>
  <pre><code>class ErroValidacao extends Error {
  constructor(public erros: string[]) {
    super("Erro de valida√ß√£o");
    this.name = "ErroValidacao";
  }
}

interface DadosFormulario {
  nome: string;
  email: string;
  idade: number;
}

function validarFormulario(dados: DadosFormulario): void {
  const erros: string[] = [];

  if (!dados.nome || dados.nome.trim().length < 3) {
    erros.push("Nome deve ter pelo menos 3 caracteres");
  }

  if (!dados.email || !dados.email.includes("@")) {
    erros.push("Email inv√°lido");
  }

  if (dados.idade < 18 || dados.idade > 120) {
    erros.push("Idade deve estar entre 18 e 120 anos");
  }

  if (erros.length > 0) {
    throw new ErroValidacao(erros);
  }
}

async function salvarUsuario(dados: DadosFormulario) {
  try {
    // Valida os dados
    validarFormulario(dados);

    // Tenta salvar
    const resposta = await fetch("https://api.exemplo.com/usuarios", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(dados)
    });

    if (!resposta.ok) {
      throw new Error("Erro ao salvar usu√°rio");
    }

    console.log("Usu√°rio salvo com sucesso!");

  } catch (erro) {
    if (erro instanceof ErroValidacao) {
      // Mostra erros de valida√ß√£o ao usu√°rio
      console.log("Erros encontrados:");
      erro.erros.forEach(e => console.log(`- ${e}`));
    } else if (erro instanceof Error) {
      // Erro de rede ou servidor
      console.error("Erro ao salvar:", erro.message);
    }
  }
}

// Testando
salvarUsuario({
  nome: "Jo",
  email: "invalido",
  idade: 15
});</code></pre>

  <p class="small-note">
    üí° <strong>Dica:</strong> Em produ√ß√£o, sempre registre erros em um servi√ßo de monitoramento
    (como Sentry, LogRocket) para identificar problemas que usu√°rios encontram.
  </p>
</section>

<section id="ts-config" class="topic">
  <h3>tsconfig.json</h3>
  <p><strong>O que √©:</strong> arquivo de configura√ß√£o do TypeScript que define como o compilador deve funcionar.</p>
  <p><strong>Por que usar:</strong> controla rigorosidade, m√≥dulos, target, e outras op√ß√µes importantes.</p>

  <h4>Configura√ß√£o b√°sica</h4>
  <pre><code>{
  "compilerOptions": {
    // Vers√£o do JavaScript gerado
    "target": "ES2020",

    // Sistema de m√≥dulos
    "module": "ESNext",
    "moduleResolution": "node",

    // Diret√≥rios
    "outDir": "./dist",          // onde salvar .js compilados
    "rootDir": "./src",           // onde est√£o os .ts

    // Qualidade e rigorosidade
    "strict": true,               // ativa todas checagens estritas
    "noImplicitAny": true,        // erro se tipo for 'any' impl√≠cito
    "strictNullChecks": true,     // null e undefined s√£o tipos separados
    "strictFunctionTypes": true,

    // Recursos extras
    "esModuleInterop": true,      // compatibilidade com imports
    "skipLibCheck": true,         // pula checagem de arquivos .d.ts
    "forceConsistentCasingInFileNames": true,

    // Source maps (para debug)
    "sourceMap": true,

    // Permite JSON imports
    "resolveJsonModule": true
  },

  "include": ["src/**/*"],        // arquivos para compilar
  "exclude": ["node_modules"]     // arquivos para ignorar
}</code></pre>

  <h4>Op√ß√µes importantes</h4>
  <pre><code>{
  "compilerOptions": {
    // Decorators (Angular, NestJS, etc)
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,

    // JSX (React)
    "jsx": "react-jsx",

    // Permite JS junto com TS
    "allowJs": true,
    "checkJs": true,

    // Remove coment√°rios do output
    "removeComments": true,

    // N√£o emite arquivos se houver erro
    "noEmitOnError": true,

    // Path aliases (imports curtos)
    "baseUrl": ".",
    "paths": {
      "@components/*": ["src/components/*"],
      "@utils/*": ["src/utils/*"]
    }
  }
}</code></pre>

  <h4>Configura√ß√µes por ambiente</h4>
  <pre><code>// tsconfig.json (base)
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "strict": true
  }
}

// tsconfig.build.json (produ√ß√£o)
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "sourceMap": false,
    "removeComments": true
  }
}

// tsconfig.test.json (testes)
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "types": ["jest", "node"]
  }
}</code></pre>

  <h4>Targets mais comuns</h4>
  <ul>
    <li><code>"ES5"</code> ‚Äì compat√≠vel com IE11 (antigo)</li>
    <li><code>"ES6"/"ES2015"</code> ‚Äì navegadores modernos b√°sicos</li>
    <li><code>"ES2020"</code> ‚Äì navegadores recentes (recomendado)</li>
    <li><code>"ESNext"</code> ‚Äì recursos mais novos dispon√≠veis</li>
  </ul>
</section>

<section id="ts-boas-praticas" class="topic">
  <h3>Boas pr√°ticas</h3>
  <p><strong>O que √©:</strong> conven√ß√µes e padr√µes para escrever TypeScript de qualidade.</p>
  <p><strong>Por que usar:</strong> c√≥digo mais leg√≠vel, manuten√≠vel e menos propenso a bugs.</p>

  <h4>1. Evite 'any' sempre que poss√≠vel</h4>
  <pre><code>// ‚ùå EVITE
function processar(dados: any) {
  return dados.valor;
}

// ‚úÖ PREFIRA
interface Dados {
  valor: number;
}

function processar(dados: Dados) {
  return dados.valor;
}

// Se realmente n√£o sabe o tipo, use 'unknown'
function processar(dados: unknown) {
  if (typeof dados === "object" && dados !== null) {
    // TypeScript te for√ßa a checar o tipo
  }
}</code></pre>

  <h4>2. Use interfaces para objetos, types para uni√µes</h4>
  <pre><code>// ‚úÖ Interface para objetos (podem ser estendidas)
interface Usuario {
  nome: string;
  email: string;
}

interface UsuarioAdmin extends Usuario {
  nivel: number;
}

// ‚úÖ Type para uni√µes, literais, aliases
type Status = "ativo" | "inativo" | "pendente";
type ID = string | number;</code></pre>

  <h4>3. Seja espec√≠fico com tipos</h4>
  <pre><code>// ‚ùå GEN√âRICO DEMAIS
function buscar(id: string): object {
  return { id, nome: "Jo√£o" };
}

// ‚úÖ ESPEC√çFICO
interface Usuario {
  id: string;
  nome: string;
}

function buscar(id: string): Usuario {
  return { id, nome: "Jo√£o" };
}</code></pre>

  <h4>4. Use readonly quando apropriado</h4>
  <pre><code>interface Config {
  readonly apiUrl: string;
  readonly timeout: number;
}

const config: Config = {
  apiUrl: "https://api.exemplo.com",
  timeout: 5000
};

// config.apiUrl = "outro"; // ‚ùå ERRO</code></pre>

  <h4>5. Prefira const assertions para literais</h4>
  <pre><code>// ‚ùå tipo ser√° string[]
const cores = ["vermelho", "verde", "azul"];

// ‚úÖ tipo ser√° readonly ["vermelho", "verde", "azul"]
const cores = ["vermelho", "verde", "azul"] as const;

// √ötil para objetos tamb√©m
const config = {
  host: "localhost",
  port: 3000
} as const;</code></pre>

  <h4>6. Use optional chaining e nullish coalescing</h4>
  <pre><code>// ‚úÖ Optional chaining (?.)
const nome = usuario?.endereco?.rua;

// ‚úÖ Nullish coalescing (??)
const porta = config.port ?? 3000;

// ‚ùå EVITE
const nome = usuario && usuario.endereco && usuario.endereco.rua;
const porta = config.port || 3000; // problema: 0 √© falsy!</code></pre>

  <h4>7. Organize imports</h4>
  <pre><code>// ‚úÖ BOA ORGANIZA√á√ÉO
// 1. Bibliotecas externas
import { useState, useEffect } from "react";
import axios from "axios";

// 2. Arquivos internos (paths absolutos)
import { Button } from "@components/Button";
import { formatarData } from "@utils/data";

// 3. Tipos
import type { Usuario } from "@types/usuario";

// 4. Estilos
import "./styles.css";</code></pre>

  <h4>8. Documente tipos complexos</h4>
  <pre><code>/**
 * Representa um usu√°rio do sistema
 * @property id - Identificador √∫nico
 * @property nome - Nome completo
 * @property role - Papel do usu√°rio (admin, user, guest)
 */
interface Usuario {
  id: string;
  nome: string;
  role: "admin" | "user" | "guest";
}

/**
 * Busca usu√°rio por ID
 * @param id - ID do usu√°rio
 * @returns Promise com dados do usu√°rio ou null se n√£o encontrado
 */
async function buscarUsuario(id: string): Promise&lt;Usuario | null&gt; {
  // implementa√ß√£o
}</code></pre>

  <h4>9. Use enums para constantes relacionadas</h4>
  <pre><code>// ‚úÖ Enum para status
enum StatusPedido {
  Pendente = "PENDENTE",
  Processando = "PROCESSANDO",
  Enviado = "ENVIADO",
  Entregue = "ENTREGUE",
  Cancelado = "CANCELADO"
}

function atualizarStatus(pedidoId: string, status: StatusPedido) {
  // TypeScript garante que s√≥ valores v√°lidos sejam passados
}

atualizarStatus("123", StatusPedido.Enviado);</code></pre>

  <h4>10. Configure linter (ESLint + TypeScript)</h4>
  <pre><code>// .eslintrc.json
{
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended"
  ],
  "parser": "@typescript-eslint/parser",
  "plugins": ["@typescript-eslint"],
  "rules": {
    "@typescript-eslint/no-explicit-any": "error",
    "@typescript-eslint/explicit-function-return-type": "warn"
  }
}</code></pre>

  <h4>Resumo das boas pr√°ticas</h4>
  <ul>
    <li>‚úÖ Ative <code>"strict": true</code> no tsconfig.json</li>
    <li>‚úÖ Evite <code>any</code>, use <code>unknown</code> quando necess√°rio</li>
    <li>‚úÖ Seja espec√≠fico com tipos de retorno de fun√ß√µes</li>
    <li>‚úÖ Use <code>readonly</code> para dados imut√°veis</li>
    <li>‚úÖ Prefira interfaces para objetos</li>
    <li>‚úÖ Use type guards em vez de type assertions</li>
    <li>‚úÖ Documente c√≥digo complexo com JSDoc</li>
    <li>‚úÖ Configure ESLint para TypeScript</li>
    <li>‚úÖ Use utility types (Partial, Pick, Omit etc)</li>
    <li>‚úÖ Organize imports de forma consistente</li>
  </ul>
</section>
